<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Socket.IO Pdf Controller</title>
  <link rel="stylesheet" href="style.css">
  <script src="//mozilla.github.io/pdf.js/build/pdf.js"></script>

  <style>
    #the-canvas {
      border: 1px solid black;
      direction: ltr;
    }
  </style>
</head>

<body>

  <p id="buttonCount">PDF Shaing</p>
  <!-- <button onclick="buttonClicked()">Click me</button> -->

  <div>
    <button onclick="PreviousbuttonClicked();" id="prev">Previous</button>
    <button onclick="NextbuttonClicked();" id="next">Next</button>

    <button id="zoominbutton" onclick="ZoominClicked()" type="button">zoom in</button>
    <button id="zoomoutbutton" onclick="ZoomoutClicked()" type="button">zoom out</button>
    <input type="hidden" id="currpos"> &nbsp; &nbsp;
    <span>Page:
      <span id="page_num"></span> /
      <span id="page_count"></span>
    </span>

  </div>
  <div id="scrollableElement" class="scrollableElement" style="height: 500px ;overflow: auto;">
    <canvas id="the-canvas"></canvas>
  </div>



  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>




  <script>
    var socket = io.connect();

    var scrollPosition;
    const scrollableElement = document.querySelector("#scrollableElement");


    function NextbuttonClicked() {
      var page_cnt = document.getElementById('page_count').innerText;
      socket.emit('nextclicked', page_cnt);
    }

    function PreviousbuttonClicked() {
      socket.emit('previousclicked');
    }


    function ZoominClicked() {
      socket.emit('zoominclicked');
    }

    function ZoomoutClicked() {
      socket.emit('zoomoutclicked');
    }


    scrollableElement.addEventListener("scroll", event => {
      scrollPosition = scrollableElement.scrollTop;
      socket.emit('scrolled', { scrollPosition: scrollPosition, uid: 100 });
    });
    // function Scroll() {
    //   console.log('gfsfdsf');


    //   var tempScrollTop = $('.scrollableElement').scrollTop();

    //   scrollPosition = tempScrollTop.toString();


    //   socket.emit('scrolled', scrollPosition);
    // }


    //when we receive numClients, do this 
    socket.on('sendfile', function (data) {
      // document.getElementById("buttonCount").innerHTML = data;
      var url = data.filePath;
      // Loaded via <script> tag, create shortcut to access PDF.js exports.
      var pdfjsLib = window['pdfjs-dist/build/pdf'];

      // The workerSrc property shall be specified.
      pdfjsLib.GlobalWorkerOptions.workerSrc = '//mozilla.github.io/pdf.js/build/pdf.worker.js';

      var pdfDoc = null,
        pageNum = data.clickCount,
        pageRendering = false,
        pageNumPending = null,
        scale = 1.8,
        canvas = document.getElementById('the-canvas'),
        ctx = canvas.getContext('2d');


      function renderPage(num) {

        pageRendering = true;

        // Using promise to fetch the page
        pdfDoc.getPage(num).then(function (page) {
          var viewport = page.getViewport({ scale: scale });
          canvas.height = viewport.height;
          canvas.width = viewport.width;

          // Render PDF page into canvas context
          var renderContext = {
            canvasContext: ctx,
            viewport: viewport
          };
          var renderTask = page.render(renderContext);

          // Wait for rendering to finish
          renderTask.promise.then(function () {
            pageRendering = false;
            if (pageNumPending !== null) {
              // New page rendering is pending
              renderPage(pageNumPending);
              pageNumPending = null;
            }
          });
        });

        // Update page counters
        document.getElementById('page_num').textContent = num;
      }

      /**
       * If another page rendering in progress, waits until the rendering is
       * finised. Otherwise, executes rendering immediately.
       */
      function queueRenderPage(num) {
        if (pageRendering) {
          pageNumPending = num;
        } else {
          renderPage(num);
        }
      }


      pdfjsLib.getDocument(url).promise.then(function (pdfDoc_) {
        pdfDoc = pdfDoc_;
        document.getElementById('page_count').textContent = pdfDoc.numPages;

        // Initial/first page rendering
        renderPage(pageNum);
      });
    });


    socket.on('buttonUpdate', function (data) {

      var url = data.filePath;
      var pageNum = data.clickCount;
      var pageNumPending = null;
      var scale = data.scale;
      var canvas = document.getElementById('the-canvas');
      var ctx = canvas.getContext('2d');
      var shownPdf;

      function renderPage(pageNum) {

        pageRendering = true;
        // Using promise to fetch the page
        pdfDoc.getPage(pageNum).then(function (page) {

          pageRendering = true;
          var viewport = page.getViewport({ scale: scale });
          canvas.height = viewport.height;
          canvas.width = viewport.width;

          // Render PDF page into canvas context
          var renderContext = {
            canvasContext: ctx,
            viewport: viewport
          };
          var renderTask = page.render(renderContext);

          // Wait for rendering to finish
          renderTask.promise.then(function () {
            pageRendering = false;
            if (pageNumPending !== null) {
              // New page rendering is pending
              renderPage(pageNumPending);
              pageNumPending = null;
            }
          });
        });

        // Update page counters
        document.getElementById('page_num').textContent = pageNum;//num;
      }

      //console.log(pageRendering);

      /**
       * If another page rendering in progress, waits until the rendering is
       * finised. Otherwise, executes rendering immediately.
       */
      function queueRenderPage(num) {
        if (pageRendering) {
          pageNumPending = num;
        } else {
          renderPage(num);
        }
      }

      /**
       * Displays previous page.
       */
      function onPrevPage() {
        if (pageNum <= 1) {
          return;
        }
        pageNum--;
        queueRenderPage(pageNum);

        if (pageNum == 1) {
          document.getElementById('prev').visibility = "hidden";
        }
      }
      // document.getElementById('prev').addEventListener('click', onPrevPage);

      /**
       * Displays next page.
       */
      function onNextPage() {
        if (pageNum >= pdfDoc.numPages) {
          return;
        }
        pageNum++;
        queueRenderPage(pageNum);

        if (pageNum == pdfDoc.numPages) {
          document.getElementById('next').visibility = "hidden";
        }
      }
      // document.getElementById('next').addEventListener('click', onNextPage);

      // var zoominbutton = document.getElementById("zoominbutton");
      // zoominbutton.onclick = 
      function zoominbutton() {
        scale = scale + 0.25;
        // displayPage(shownPdf, pageNum);
        queueRenderPage(pageNum);
      }
      // document.getElementById('zoominbutton').addEventListener('click', zoominbutton);

      // var zoomoutbutton = document.getElementById("zoomoutbutton");
      // zoomoutbutton.onclick = 
      function zoomoutbutton() {
        if (scale <= 0.25) {
          return;
        }
        scale = scale - 0.25;
        // displayPage(shownPdf, pageNum);
        queueRenderPage(pageNum);
      }
      // document.getElementById('zoomoutbutton').addEventListener('click', zoomoutbutton);





      pdfjsLib.getDocument(url).promise.then(function (pdfDoc_) {
        pdfDoc = pdfDoc_;
        document.getElementById('page_count').textContent = pdfDoc.numPages;
        renderPage(pageNum);
      });

    });


    socket.on('scrolling', function (data) {

      console.log(data.id);

      $(scrollableElement).scrollTop(scrollPosition);
      // scrollableElement.scrollTop = data.pos;

    });


  </script>
</body>

</html>